"""
    pygments.lexers.sdt
    ~~~~~~~~~~~~~~~~~~~~~~

    Lexers for Matlab and related languages.

    :copyright: Copyright 2006-2017 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.

    Modified by JÃ¸rgen Cederberg from orignial Pygments MATLAB lexer, copied
    from https://bitbucket.org/birkenfeld/pygments-main/src/f6637a95d0d8534abb2c1e128e3d5c88d09e96e3/pygments/lexers/matlab.py
    - Added handling of double quoted strings.
    - Fixed issues with function keyword matched incorrectly.
    - Removed unused lexers (MatlabSessionLexer, OctaveLexer, ScilabLexer)
   Modified by Guillaume Martin to add SDT keywords

"""

from pygments.lexer import RegexLexer, bygroups, words
from pygments.token import (  # noqa: F401
    Token,
    Text,
    Comment,
    Operator,
    Keyword,
    Name,
    String,
    Number,
    Punctuation,
    Whitespace,
)

__all__ = ["MatlabLexer"]


class MatlabLexer(RegexLexer):
    """
    For Matlab source code.

    .. versionadded:: 0.10
    """

    name = "Matlab"
    aliases = ["matlab"]
    filenames = ["*.m"]
    mimetypes = ["text/matlab"]

    #
    # These lists are generated automatically.
    # Run the following in bash shell:
    #
    # for f in elfun specfun elmat; do
    #   echo -n "$f = "
    #   matlab -nojvm -r "help $f;exit;" | perl -ne \
    #   'push(@c,$1) if /^    (\w+)\s+-/; END {print q{["}.join(q{","},@c).qq{"]\n};}'
    # done
    #
    # elfun: Elementary math functions
    # specfun: Special Math functions
    # elmat: Elementary matrices and matrix manipulation
    #
    # taken from MATLAB version'9.6.0.1092380 (R2019a) Update 1'
    #
    # Use command sdth.docutils('sdtfun-sdtlexer') to generate the sdtfun list below
    sdtfun = (
     "abaqus",
     "anisotropic_cristal",
     "ans2sdt",
     "bar1",
     "basis",
     "beam1",
     "beam1t",
     "beam3",
     "bridge_with_thermal",
     "calme12",
     "cbush",
     "cdm",
     "celas",
     "cingui",
     "cinguj",
     "comgui",
     "commode",
     "convert",
     "ctc_utils",
     "curvemodel",
     "cvs",
     "d_acous",
     "d_cms",
     "d_contact",
     "d_cor",
     "d_dft",
     "d_doe",
     "d_feplot",
     "d_fetime",
     "d_imw",
     "d_mesh",
     "d_nlstatic",
     "d_piezo",
     "d_pml",
     "d_primer",
     "d_range",
     "d_rotor",
     "d_shm",
     "d_signal",
     "d_sim",
     "d_squeal",
     "d_statespace",
     "d_training",
     "d_visco",
     "dbsdt",
     "demo_cyclic",
     "demos",
     "demosdt",
     "devkey",
     "dktp",
     "elem0",
     "esi2sdt",
     "ex2sdt",
     "excite2sdt",
     "exportToPPTX",
     "fe2ss",
     "fe2xf",
     "fe_c",
     "fe_case",
     "fe_caseg",
     "fe_ceig",
     "fe_cmt",
     "fe_coor",
     "fe_curve",
     "fe_cyclic",
     "fe_cyclicb",
     "fe_dd",
     "fe_def",
     "fe_eig",
     "fe_exp",
     "fe_fmesh",
     "fe_gmsh",
     "fe_homo",
     "fe_honeycomb",
     "fe_load",
     "fe_mat",
     "fe_mk",
     "fe_mknl",
     "fe_mpc",
     "fe_norm",
     "fe_quality",
     "fe_range",
     "fe_reduc",
     "fe_rotor",
     "fe_sens",
     "fe_shapeoptim",
     "fe_simul",
     "fe_stress",
     "fe_super",
     "fe_tetgen",
     "fe_time",
     "fe_var",
     "fecom",
     "fegui",
     "femesh",
     "femlink",
     "feplot",
     "feplotj",
     "fesuper",
     "feutil",
     "feutilb",
     "feutilg",
     "fevisco",
     "ffindstr",
     "fjlock",
     "flui4",
     "flui6",
     "flui8",
     "fsc",
     "fsc3",
     "funref",
     "gartid",
     "getegroup",
     "gid",
     "h125",
     "h64",
     "h8pz",
     "hexa20",
     "hexa20b",
     "hexa27",
     "hexa8",
     "hexa8a",
     "hexa8b",
     "id_dspi",
     "id_forse",
     "id_min",
     "id_nor",
     "id_poly",
     "id_rc",
     "id_rcopt",
     "id_rm",
     "id_rot",
     "idacq",
     "idcom",
     "idiplot",
     "idopt",
     "idoptu",
     "ii_cost",
     "ii_csel",
     "ii_fin",
     "ii_frame",
     "ii_mac",
     "ii_mmif",
     "ii_plp",
     "ii_poest",
     "ii_pof",
     "ii_signal",
     "iicom",
     "iigui",
     "iimouse",
     "iiplot",
     "impmat",
     "integrules",
     "itertheta_nl",
     "jfreqmac",
     "lat",
     "line2",
     "line3",
     "lsutil",
     "m2ph",
     "m_cardio",
     "m_elastic",
     "m_heat",
     "m_hyper",
     "m_piezo",
     "m_poro",
     "m_pstress",
     "m_visc",
     "m_visco",
     "make_dis_2",
     "marc2sdt",
     "mass1",
     "mass2",
     "matfun",
     "matgui",
     "mck3",
     "medit",
     "menu_generation",
     "mitc4",
     "moldflow",
     "mvisco_3m",
     "mvisco_aderis",
     "mvisco_artec",
     "mvisco_calme",
     "mvisco_ecp",
     "mvisco_henkel",
     "mvisco_metravib",
     "mvisco_smac",
     "nasread",
     "nastran_dialogs",
     "naswrite",
     "nl_contact",
     "nl_contactl",
     "nl_frictionl",
     "nl_frot",
     "nl_fun",
     "nl_inout",
     "nl_localslider",
     "nl_maxwell",
     "nl_mesh",
     "nl_modaldmp",
     "nl_modalinertia",
     "nl_movingl",
     "nl_pml",
     "nl_rotcenter",
     "nl_slip",
     "nl_solve",
     "nl_spring",
     "nlutil",
     "node1",
     "nopo",
     "nor2res",
     "nor2ss",
     "nor2xf",
     "of2vtk",
     "ofdemos",
     "ofutil",
     "omat",
     "openbdf",
     "order",
     "p_beam",
     "p_contact",
     "p_heat",
     "p_mitc",
     "p_piezo",
     "p_pml",
     "p_poro",
     "p_shell",
     "p_solid",
     "p_spring",
     "p_super",
     "p_thermo",
     "p_zt",
     "pak2sdt",
     "penta15",
     "penta15b",
     "penta18",
     "penta6",
     "penta6b",
     "perm2sdt",
     "phaseb",
     "pmat",
     "polytec",
     "process_r",
     "propgui",
     "psi2nor",
     "pulse2sdt",
     "pyra13",
     "pyra5",
     "q16p",
     "q25p",
     "q36p",
     "q4cs",
     "q4p",
     "q4pb",
     "q4up",
     "q5p",
     "q8p",
     "q8pb",
     "q8up",
     "q9a",
     "qbode",
     "quad4",
     "quad9",
     "quadb",
     "quadc",
     "rangemodel",
     "remi",
     "res2nor",
     "res2ss",
     "res2tf",
     "res2xf",
     "rigid",
     "rmatlab",
     "rotor1d",
     "rotor2d",
     "samcef",
     "sap2sdt",
     "sd",
     "sd_pref",
     "sdcedit",
     "sddesk",
     "sdsetprop",
     "sdtTreeTable",
     "sdtacx",
     "sdtcheck",
     "sdtcode",
     "sdtdef",
     "sdth",
     "sdthdf",
     "sdticons",
     "sdtjob",
     "sdtkey",
     "sdtm",
     "sdto",
     "sdtpy",
     "sdtr_utils",
     "sdtroot",
     "sdtslave",
     "sdtsys",
     "sdtw",
     "sdtweb",
     "se_gimbal",
     "setlines",
     "simpack",
     "ss2res",
     "stack_cell",
     "stack_get",
     "stack_rm",
     "stack_set",
     "strutil",
     "t3p",
     "t3pb",
     "t6p",
     "t6pb",
     "tetra10",
     "tetra10b",
     "tetra4",
     "tetra4b",
     "timing",
     "tria3",
     "tria6",
     "uf_link",
     "ufread",
     "ufwrite",
     "up_freq",
     "up_ifreq",
     "up_ixf",
     "up_min",
     "up_psel",
     "upcom",
     "visc_eg",
     "votcenter",
     "xfopt",
    )
    elfun = (
        "sin",
        "sind",
        "sinh",
        "asin",
        "asind",
        "asinh",
        "cos",
        "cosd",
        "cosh",
        "acos",
        "acosd",
        "acosh",
        "tan",
        "tand",
        "tanh",
        "atan",
        "atand",
        "atan2",
        "atan2d",
        "atanh",
        "sec",
        "secd",
        "sech",
        "asec",
        "asecd",
        "asech",
        "csc",
        "cscd",
        "csch",
        "acsc",
        "acscd",
        "acsch",
        "cot",
        "cotd",
        "coth",
        "acot",
        "acotd",
        "acoth",
        "hypot",
        "deg2rad",
        "rad2deg",
        "exp",
        "expm1",
        "log",
        "log1p",
        "log10",
        "log2",
        "pow2",
        "realpow",
        "reallog",
        "realsqrt",
        "sqrt",
        "nthroot",
        "nextpow2",
        "abs",
        "angle",
        "complex",
        "conj",
        "imag",
        "real",
        "unwrap",
        "isreal",
        "cplxpair",
        "fix",
        "floor",
        "ceil",
        "round",
        "mod",
        "rem",
        "sign",
    )
    specfun = (
        "airy",
        "besselj",
        "bessely",
        "besselh",
        "besseli",
        "besselk",
        "beta",
        "betainc",
        "betaincinv",
        "betaln",
        "ellipj",
        "ellipke",
        "erf",
        "erfc",
        "erfcx",
        "erfinv",
        "erfcinv",
        "expint",
        "gamma",
        "gammainc",
        "gammaincinv",
        "gammaln",
        "psi",
        "legendre",
        "cross",
        "dot",
        "factor",
        "isprime",
        "primes",
        "gcd",
        "lcm",
        "rat",
        "rats",
        "perms",
        "nchoosek",
        "factorial",
        "cart2sph",
        "cart2pol",
        "pol2cart",
        "sph2cart",
        "hsv2rgb",
        "rgb2hsv",
    )
    elmat = (
        "zeros",
        "ones",
        "eye",
        "repmat",
        "repelem",
        "linspace",
        "logspace",
        "freqspace",
        "meshgrid",
        "accumarray",
        "size",
        "length",
        "ndims",
        "numel",
        "disp",
        "isempty",
        "isequal",
        "isequaln",
        "cat",
        "reshape",
        "diag",
        "blkdiag",
        "tril",
        "triu",
        "fliplr",
        "flipud",
        "flip",
        "rot90",
        "find",
        "end",
        "sub2ind",
        "ind2sub",
        "bsxfun",
        "ndgrid",
        "permute",
        "ipermute",
        "shiftdim",
        "circshift",
        "squeeze",
        "isscalar",
        "isvector",
        "isrow",
        "iscolumn",
        "ismatrix",
        "eps",
        "realmax",
        "realmin",
        "intmax",
        "intmin",
        "flintmax",
        "pi",
        "i",
        "inf",
        "nan",
        "isnan",
        "isinf",
        "isfinite",
        "j",
        "true",
        "false",
        "compan",
        "gallery",
        "hadamard",
        "hankel",
        "hilb",
        "invhilb",
        "magic",
        "pascal",
        "rosser",
        "toeplitz",
        "vander",
        "wilkinson",
    )

    tokens = {
        "root": [
            # line starting with '!' is sent as a system command.  not sure what
            # label to use...
            (r"^!.*", String.Other),
            (r"%\{\s*\n", Comment.Multiline, "blockcomment"),
            (r"%.*$", Comment),
            (r"^\s*function(?=[\s[])", Keyword, "deffunc"),
            # from 'iskeyword' on version 7.11 (R2010):
            (
                words(
                    (
                        "arguments",
                        "break",
                        "case",
                        "catch",
                        "classdef",
                        "continue",
                        "else",
                        "elseif",
                        "end",
                        "enumerated",
                        "events",
                        "for",
                        "global",
                        "if",
                        "methods",
                        "otherwise",
                        "parfor",
                        "persistent",
                        "properties",
                        "return",
                        "spmd",
                        "switch",
                        "try",
                        "while",
                    ),
                    prefix=r"(?<!\.)(",
                    suffix=r")\b",
                ),
                Keyword,
            ),
            ("(" + "|".join(elfun + specfun + elmat) + r")\b", Name.Builtin),
            ("(" + "|".join(sdtfun) + r")\b", Name.Other),
            # line continuation with following comment:
            (r"\.\.\..*$", Comment),
            # operators:
            (r"-|==|~=|<|>|<=|>=|&&|&|~|\|\|?", Operator),
            # operators requiring escape for re:
            (r"\.\*|\*|\+|\.\^|\.\\|\.\/|\/|\\", Operator),
            # punctuation:
            (r"\[|\]|\(|\)|\{|\}|:|@|\.|,", Punctuation),
            (r"=|:|;", Punctuation),
            # quote can be transpose, instead of string:
            # (not great, but handles common cases...)
            (r"(?<=[\w)}\].])\'+", Operator),
            (r"(\d+\.\d*|\d*\.\d+)([eEf][+-]?[0-9]+)?", Number.Float),
            (r"\d+[eEf][+-]?[0-9]+", Number.Float),
            (r"\d+", Number.Integer),
            (r'"(""|[^"])*"', String),
            (r"(?<![\w)}\].])\'", String, "string"),
            (r"[a-zA-Z_]\w*", Name),
            (r".", Text),
        ],
        "string": [
            (r"[^']*'", String, "#pop"),
        ],
        "blockcomment": [
            (r"^\s*%\}", Comment.Multiline, "#pop"),
            (r"^.*\n", Comment.Multiline),
            (r".", Comment.Multiline),
        ],
        "deffunc": [
            (
                r"(\s*)(?:(.+)(\s*)(=)(\s*))?(.+)(\()(.*)(\))(\s*)",
                bygroups(
                    Whitespace,
                    Text,
                    Whitespace,
                    Punctuation,
                    Whitespace,
                    Name.Function,
                    Punctuation,
                    Text,
                    Punctuation,
                    Whitespace,
                ),
                "#pop",
            ),
            # function with outputs but no inputs
            (
                r"(\s*)(?:(.+)(\s*)(=)(\s*))?([a-zA-Z_]\w*)",
                bygroups(
                    Whitespace, Text, Whitespace, Punctuation, Whitespace, Name.Function
                ),
                "#pop",
            ),
            # function with no inputs or outputs
            (r"(\s*)([a-zA-Z_]\w*)", bygroups(Text, Name.Function), "#pop"),
        ],
    }